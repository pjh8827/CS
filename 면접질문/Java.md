## Java

### 1. JVM구조에 대해 설명하시오.

**정의 :** **자바 바이트 코드를 실행할 수 있는 주체**
Jvm구조는 크게 3가지 영역으로 나누어 말씀드릴 수 있습니다. 첫번째로 자바 컴파일로부터 컴파일된 클래스파일을 JVM내로 로드, 링크를 통해 배치하는 모듈인 클래스 로더, 두번째로 클래스로더가 배치 시킨  클래스를 실행시키는 역할인 Execution Engin이 있습니다. 이것은 바이트 코드를 실제로 JVM내부에서 기계가 실행할 수 있는 형태로 변경합니다. 이때 인터프리터, JIT 두가지 방식을 사용합니다. GC를 실행하는 모듈도 이곳에 존재합니다. 세번째로는 이러한 프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간인 Runtime Data Area가 있습니다. 이는 크게 Method Area(class area 또는 static area)와 힙 영역, PC Register, JVM 스택 영역, Native method stack영역으로 나뉩니다. 그리고 PC Register, JVM  스택 영역, Native method stack영역은 각각의 스레드마다 각각의 달리 할당받습니다.

### 2. GC처리방법에 대해 설명하시오

가비지 컬렉션에서는 첫번째로 **Minor GC**가 발생합니다. 새로 생성된 대부분의 객체는 Eden영역에 위치하고 Eden영역에서 GC가 한번 발생 후 살아남은 객체는 Survivor 영역 중 하나로 이동된다. 이 과정이 Minor GC이며 이것이 반복하다가 계속해서 살아남아 있는 객체는 일정시간 참조되고 있다는 뜻이므로 Old영역으로 이동시킨다. 두번째로 **Major GC**가 발생합니다. Old영역에 있는 모든 객체들을 검사하여 참조되지 않은 객체들을 한꺼번에 삭제한다. 시간이 오래걸리고 실행 중 프로세스가 정지된다. 이것을 'stop-the-world'라고 하는데 Major GC가 발생하면 GC를 실행하는 스레드를 제외한 나머지 스레드는 모두 작업을 멈춘다. 
  사용하는 알고리즘에 따라 동작 방식이 매우 다양하지만 공통적인 원리가 있다. Garbage Collector는 힙 내의 객체 중에서 가비지를 찾아내고 찾아낸 가비지를 처리해서 힙의 메모리를 회수한다. 이 때 참조되고 있는 객체를 reachability, 없다면 unreachability로 판단한다. 이러한 유효한 참조는 힙내의 다른 객체에 의한 참조를 제외한 3가지가 있다. 1. JAVA스택, 즉 java method 실행 시에 사용되는 지역변수와 파라미터에 의한 참조 2. Native 스택(JNI)에 의해 생성된 객체에 대한 참조, 3. 메서드 영역의 정적 변수에 의한 참조. 

거시적인 관점에서의 작업수행은 2가지 작업으로 나뉠 수 있다.
1) 힙 내의 객체 중에서 가비지를 찾아낸다. 
2) 찾아낸 가비지를 처리해서 힙의 메모리를 회수한다.

### 3. HashMap vs HashTable vs ConcurrentHashMap의 차이를 설명하시오.

공통점은 Map 인터페이스를 구축하기 때문에 <key, value> 구조를 지닌다는 것이다. 
**HashMap** = synchronized 키워드가 없기 때문에 동기화가 보장되지 못한다. 데이터의 무결성에 문제가 생긴다. (싱글 스레드 환경에서 사용하여야한다) 따라서 동기화 처리를 하지 않기 때문에 값을 찾는 속도가 상당히 빠르다. 또한 HashTable과 다르게 Key,value null값을 허용한다. 즉 속도가 빠르지만, 신뢰성 안정성이 떨어진다.
**ConCurrentHashMap** = HashMap의 멀티스레드 환경에서의 동기화처리로 인한 문제점을 보완한 것이다. 하지만 HashMap과 다르게 key,value에 null을 허용하지 않는다.
**HashTable** = HashTable의 메서드는 전부 synchronized 키워드가 붙어있기 때문에 메서드 호출 전 쓰레드간 동기화 락을 통해 멀티 쓰레드 환경에서 data의 무결성을 보장해준다. 또한 key.value값의 null을 허용하지 않는다. 즉 동기화 락때문에 속도는 느리지만, data의 안정성이 높고 신뢰가 높은 컬렉션이다.

### 4. 접근제어자에 대해 설명하시오

자바에는 다음과 같은 접근 제어자가 있다. 
1) private
2) default
3) protected
4) public

Private = 접근제어자가 private인 변수, 메서드는 해당 클래스에서만 접근이 가능하다.
Default = 해당 패키지 내에서만 접근이 가능하다.
Protected = 접근제어자가 protected인 변수, 메서드는 동일 패키지내의 클래스 또는 해당 클래스를 상속받은 외부 패키지의 클래스에서 접근이 가능하다.
public = 접근제어자가 public인 변수, 메서드는 어떤 클래스에서라도 접근 가능하다.

### 5. Interface와 abstract의 차이

**공통점** : 선언만 있고, 구현 내용이 없는 클래스이다. 그래서 자기 자신이 new를 해서 객체를 생성할 수 없으며, 추상클래스를 extends받거나 interface를 implements한 자식만이 객체를 생성할 수 있다. 상속받은 자식이 구현을 반드시 하도록 해야할 때 사용한다.  Java에서는 type이 지정되있기 때문에 선언된 type과 자식의 type이 같아야만 한다.

**차이점** : 추상클래스는 말 그대로 클래스이고, interface는 구현하기 전에 메소드에 대해 명세된 것이다. 그래서 상속을 받음에도 불구하고 클래스에선 상속이라고 쓰지만 interface는 implements(구현) 이라고 쓴다.
  추상클래스의 정의는 abstract 메소드가 하나라도 존재하는 클래스를 일컫는다. 때문에 일부는 구현된 메소드도 있고, abstract라고 붙어있는 메소드는 구현이 안되어있다.
  추상클래스를 상속받는 클래스는 반드시 추상메소드를 구현해야한다. 그래서 필수적으로 구현해야할 메소드가 있을 때 추상클래스를 쓰게된다. 
  인터페이스는 구현체 없이, 메소드에 대한 명세만 되어있다. 인터페이스를 상속받는 클래스에서는 반드시 인터페이스에 있는 메소드를 다 구현해야한다. 
  자바는 단일상속을 지원하기 때문에 추상클래스는 단일상속이지만, interface를 사용하게 되면, implements를 구현하는 부분에서 extends 또한 사용할 수 있다. 즉 다중상속이 가능해진다. 
1) ~메소드를 쓸것이다(인터페이스) = 반드시 선언된 그대로 모두 구현해야한다. 
2) ~메소드가 있지만 가져다 쓰고나 오버라이드 하거나, abstract가 붙은 메소드는 반드시 구현하면 되는게 abstract class이다. 

#### 인터페이스에는 다형성(Polymorphism) 개념 등장!

interface : 동물. Method : 먹는다, 걷는다, 잔다.
= 구현체(implement) : 고양이, 원숭이, 병아리
동물 각각이 먹고 걷는, 자는 방식을 구현

#### 추상클래스는 언제 쓰는가?

야생고양이가 새끼를 낳았다. 인간에 의해 집고양이가 된 경우!
어미고양이(부모글래스)-야생고양이
-자는법 (메서드)
-집에서 사는법(추상화 메서드)
새끼고양이(자식클래스)-집고양이
-자는법(메서드)
-집에서 사는법(메서드)
어미고양이는 야생고양이므로 집에서 사는법은 모르지만, 새끼고양이는 집에서 사는법을 알려주기 위해 추상메서드로 만들었다. (구현 X)

=인터페이스는 다형성! 추상화 상속은 부모-자식관계!

### 6. StringBuilder와 StringBuffer의 차이에 대해 설명하시오.

String, StringBuffer, StringBuilder 는 모두 문자열을 저장하고 관리하는 클래스들이다. String은 immutable(불변)하고, StringBuffer, StringBuilder는 mutable(가변)하다는 점이다. 
쉽게 말해서 String은 new연산을 통해 생성되면 그 인스턴스의 메모리 공간은 절대 변하지 않는다. 그래서 +연산이나 concat을 이용해서 문자열에 변화를 줘도 메모리 공간이 변하는 것이 아니라 새로운 String 객체를 new로 만들어서 새로운 메모리 공간을 만드는 것이다. 이렇게 새롭게 만들어지면 GC에 의해 제거되어야 하는 단점이 있다. 그리고 이렇게 계속해서 객체를 만들면 오버헤드가 발생하므로 성능이 떨어질 수 밖에 없다. 대신 String 클래스의 객체는 불변하기 때문에 단순하게 읽어가는 조회연산에서는 타 클래스보다 빠르게 읽을 수 있는 장점이 있다. (+불변하기 때문에 멀티쓰레드환경에서 동기화를 신경쓸 필요가 없음(장점))
**결론: String 클래스는 문자열 연산이 적고 조회가 많을 때 멀티쓰레드 환경에서 사용하면 좋음**
StringBuffer와 StringBuilder 클래스는 String과 다르게 mutable(가변)이다. 즉 문자열 연산에 있어서 클래스는 한번만 만들고(new), 연산이 필요할 때 크기를 변경시켜서 문자열을 변경한다. 그러므로 문자열 연산이 자주 있을 때 사용하면 성능이 좋다. 이 둘은 메서드들이 같으므로 호환이 가능하다.
이 둘의 차이점은 StringBuffer는 멀티쓰레드환경에서 synchronized키워드가 가능하므로 동기화가 가능하다. 즉 thread-safe하다. StringBuilder는 동기화를 지원하지 않기 때문에 멀티쓰레드 환경에는 부적합하다. 대신 동기화를 고려하지 않기 때문에 싱글쓰레드 환경에서 StringBuffer에 비해 연산처리가 빠르다
결론 = 문자열 연산이 많을 때 멀티쓰레드 환경에서는 StringBuffer, 싱글쓰레드 또는 쓰레드를 신경쓰지 않아도 되는 환경에서는 StringBuilder를 사용하는 것이 적절하다. 

### 7. Try-with-resources에 대해 설명하시오.

try()문의 자신의 변수인 객체를 close()해준다. 이를 위해선 AutoCloseable 인터페이스를 추가해주면된다. 기본으로 AutoCloseable을 지원해주는 객체들이 있지만 없더라도 저렇게 객체에게 implement 시켜주면 된다(해당 입출력 객체가 AutoCloseable 인터페이스를 구현해야 한다).
1) 외부자원을 사용한 뒤 finally에서 직접 자원을 닫아주지 않아도 알아서 자원을 닫아준다. (Java io의 Stream 클래스들은 내부변수에 대한 close()를 호출한다.)
2) 예외시 자원을 자동으로 닫아주며 이를 받아주는 예외상황을 catch에서 잡아주면 된다.  

### 8. Synchronize에 대해 설명하시오.

자바의 Thread Class의 동기화가 필요한 경우에 사용하는 키워드로서 Synchronized block에서 다른 스레드가 작업을 수행중일 경우에 다른 스레드가 이 영역의 작업을 수행하지 못하도록 하는 키워드이다. 즉 data의 thread-safe(무결성)을 지키기 위해 자바에서 제공하는 기능. 

### 9. Synchronize를 하기 위한 방법은 무엇이 있나요?

1. 메서드에서 사용하는 경우
   public synchronized void method(){//코드}
2. 객체 변수에 사용하는 경우(block문)
   private Object obj = new Object();
   public void exampleMethod(){ synchronized(obj){//코드}}

공유데이터에 대한 접근과 수정이 이루어지는 메서드에 synchronized 키워드를 리턴타입 앞에 붙여주면 된다. T1스레드가 먼저 공유데이터나 메서드에 점유하고 있는 상태인 경우 block으로 처리하기 때문에 T1 이외의 스레드의 접근을 막는다. T1 작업을 다 끝냈다면, .unblock으로 처리하여 t1 이외의 스레드의 접근을 허락한다.

<synchronized 키워드로 멀티스레드 동기화 처리>

Synchronized 키워드를 사용함으로써 balance 공유 데이터에 대한 thread-safe를 시켰기 때문에 데이터나 메서드 점유하고 있는 스레드가 온전히 자신의 작업을 마칠 수 있다.

+추가

메소드 레벨의 동기화는 해당 인스턴스 자체로 락을 걸어버린다. 자바 동기화 블록은 메소드나 블록 코드에 동기화 영역을 표시하며 자바에서 경합 조건을 피하기 위한 방법으로 쓰인다. 

**자바 synchronized 키워드**

자바 코드에서 동기화 영역은 synchronized 키워드로 표시된다. 동기화는 객체에 대한 동기화로 이루어지는데 (synchronized on some object), 같은 객체에 대한 모든 동기화 블록은 한 시점에 오직 한 쓰레드만이 블록 안으로 접근하도록 - 실행하도록 - 한다. 블록에 접근을 시도하는 다른 쓰레드들은 블록 안의 쓰레드가 실행을 마치고 블록을 벗어날 때까지 블록(blocked) 상태가 된다. 

Synchronized 키워드는 다음 네가지 유형의 블록에 쓰인다.
1) 인스턴스 메소드 - 인스턴스당 한 쓰레드.
2) 스태틱 메소드 - 클래스당 한 쓰레드.
3) 인스턴스 메소드 코드블록 - 메소드 안에 동기화 블록을 따로 작성
4) 스태틱 메소드 코드블록 - 각 메소드를 가지고 있는 클래스 객체를 동기화 기준으로 잡는다. (질문!!)

### 10. static은 메모리 구조 중 어디에 올라가나요?

필드 정보(멤버변수, 데이터 타입, 접근제어자에 대한 정보),
메서드 정보(메소드 이름, 리턴 타입, 접근제어자에 대한 정보),
타입 정보(class인지, Interface인지)
  패키지나 클래스정보가 올라간다.
  패키지나 클래스는 프로그램 시작과 동시에 모두 올라가는 것이 아니라, 실제 호출될 때 올라간다. 

### 11. 컬렉션 프레임워크에 대해 설명하시오.

다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미한다. 즉 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 것이다.

### 12. 제네릭에 대해 설명해주세요.

컴파일과정에서 타입체크, 객체의 타입안정성을 높인다. collection에 특정 객체만 추가될 수 있도록 한다. **코드블럭 내부에서 쓸 자료형을 외부에서 지정하는 기법.** 제네릭 클래스, 제네릭 메서드, 제네릭 인터페이스. 
와일드 카드 = 타입을 제한하는 것. 이때 3가지 방법으로 와일드 카드 사용 가능
1) T  Extends class :
2) T Extends interface : 
3) T super class:

### 13. Vector와 List 차이에 대해 설명하시오.

vector는 동기화를 지원하여 멀티 쓰레드 환경에서 데이터의 무결성을 지킬 수 있는 반면에 락에 의한 성능저하가 발생한다. 연속적인 메모리, 미래에 들어갈 요소 위해 선할당을 하고, 메모리 재할당 가능
list는 동기화가 없기 때문에 단일 쓰레드에서 vector에 비해 우수한 성능을 보이며 때에 따라서 싱크로나이즈를 추가하여 데이터의 무결성을 지킬 수 있다. 선할당 안함. 추가제거 잦을 시 사용.

### 14. 오버로딩(Overloading) 과 오버라이딩(Overriding)

둘 다 다형성을 지원하는 방법에서 나왔으며, 오버로딩은 같은 이름의 함수를 다른 매개변수, 갯수를 달리하여 다양한 유형의 호출에 응답할 수 있게 한다. 오버라이딩의 경우 부모로부터 상속받은 메소드를 재정의 함으로써 재사용을 가능케 하는 것을 말한다. 

### 15. CheckedException과 UnCheckedException의 차이를 설명하시오.

CheckedException : 반드시 예외처리를 해야하미. 컴파일 단계에서 에러남.
Ex) IOException, SQLException
UnCheckedException : 예외처리 강제안함. 실행단계에서 일어남.
ex) NullPointer, ILLegarArgument, OutOfBoundException 등등

### 16. OOP란 무엇인가?

객체지향, 크게 3가지 특징이 있다. 추상화, 캡슐화, 다형성, 상속
추상화 : 객체들의 공통적인 특징(속성과 기능)을 뽑아내는 것이다. 굳이 구현할 필요없는 부분을 생략하고 필요한 부분만을 나타내는것.
다형성: 하나의 메소드나 클래스가 다양한 방법으로 동작하게하는 요소, 단순한 상속이나 인터페이스가 구현이 된 클래스, 오버로딩, 오버라이딩이 있다. 
캡슐화 : 메소드의 기능만 알며, 어떻게 동작하는지 알필요 없이 사용하는 것.
상속성: 상위개념의 특징을 하위 개념이 물려받는 것을 말한다. 

장점 : 

1. 프로그램을 유연하고 변경이 용이하게 만든다.

2. 프로그램의 개발과 보수를 간편하게 만든다.

3. 직관적인 코드 분석을 가능하게 한다.

   => 강한 응집력 + 약한 결합력

기본 구성 요소 : 클래스, 객체. 메서드

### 17. Final/ finally/ finalize의 차이를 설명하세요.

final : 변경 불가능
Finally : 예외처리에서 무조건 실행하는것.
Finallize() :  GC에 의해 호출되는 메소드, 이를 제대로 처리해주지않으면 OOME 발생.
=> final class : 상속 X, final method : Overriding X, final var : 상수

### 18. new String()과 ""의 차이에 대해 설명해주세요. 

new String()은. heap내의 spring pool에 객체 생성 뒤 그 객체의 주소를 가지게 되는것 ""는 문자열 자체를 상수풀에 저장 후 그 배열의 인덱스 번호를 가리킴

### 19. 스프링 IOC가 무엇인가요?

제어의 역전으로, 제어권을 스프링에게 위임하며 스프링이 만들어둔 객체를 주입한다. 스프링이 모든 의존성 객체를 스프링이 실행될 때 만들어두고 필요한 곳에 주입시켜준다. 그래서 Bean들은 싱글턴패턴의 특징을 가진다. 그렇게 제어의 흐름을 사용자가 아닌 스프링이 갖고 작업을 처리하는것이 IOC이며, 이를 구현하는 방법중 DI가 있다. 내가 new 객채를 만드는것이 아니고 스프링이 필요할 때 자기가 알아서 만든다. 

### 20. OOP와 AOP에 대한 차이를 설명해주세요.

OOP: 모든 데이터를 오브젝트로 취급하여 프로그래밍하는 방법. 독립적으로 사용하거나 부품으로 사용하므로 재사용성 및 결합 가능
AOP: 관점지향, 코드 밖에서 설정된다. ex)logger. OOP에서 프로그램의 크기가 엄청나게 커지면서 이러한 모듈 안에서마저 중복되는 코드가 생기게 되고 이름 횡단 관심사(Crosscutting-Concerns)라고 한다. 그 중 자주 언급되는 것이 바로 트랜잭션, 로깅, 성능 분석 등이다. 이러한 횡단 관심사들은 여러 모듈들을 말 그대로 횡단하면서 존재한다. 
  AOP의 목적은 바로 이러한 횡단관심사를 모듈화 하는 방법을 제시하는 것이다. 객체지향을 보조하는 역할을 한다고 보면된다. 개발자는 핵심로직에 보다 더 집중할 수 있도록, 부가로직으로부터 자유롭게 해준다. 

### 21. POJO가 무엇인가?

getter, setter로 이루어진 단순한 Java Bean. 별도의 API가 필요하지 않은 일반적인 자바코드를 이용해서 개발 가능한 것들.  

### 22. Annotation이란?

주석처럼 코드를 살며, 클래스에 의미를 부여하거나 기능을 주입할 수 있다. Build-in annotation, meta annotation, custom annotation이 있다.