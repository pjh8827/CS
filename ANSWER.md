# 면접 질문 모음

1. 자바

   1. Reflection 설명하시오.

      =구체적인 클래스 타입을 알지 못해도, 그 클래스의 메소드, 타입, 변수들을 접근할 수 있도록 해주는 자바 API다.

      이유: 자바 클래스 파일은 바이트 코드로 컴파일되어 Static 영역에 위치하게 된다. 때문에 클래스 이름만 알고 있다면, 언제든 이 영역을 뒤져서 클래스에 대한 정보를 가져올 수 있는 것이다.

      ------------------------------------------------------

      스프링을 공부하다가 보면 BeanFactory 라는 Spring Container 개념을 학습하게 된다.

      이 BeanFactory는 어플리케이션이 실행한 후 객체가 호출 될 당시 객체의 인스턴스를 생성하게 되는데 

      그 때 필요한 기술이 Reflection이다.

       https://brunch.co.kr/@kd4/8

   2. Getter, Setter 함수를 써야하는가?

      이는 캡슐화, 정보은닉을 통해 객체의 무결성을 보장하기 위함.  외부에서 직접적으로 접근하는 것을 막아두는 것.
      내 생일은 생성할때 빼곤 사용할 일이 없기 때문에 Setter를 두지 않아도 된다. 또는 성적에는 -값이 들어갈 일이 없으므로 예외처리 해둘 수 있다.

   3. POJO가 무엇인지 설명하시오
      객체지향적인 원리에 충실하면서, 특정 규약, 환경에 종속되지 않고, 단일 책임 원칙을 지키는 오브젝트.  

   4. 접근제어자를 설명하시오

      Private : 현재 클래스 내에서만 사용할 수 있는 매개변수 또는 함수

      Default : 현재 클래스 내, 같은 패키지 내에서만 사용할 수 있는 매개변수 또는 함수

      Protected : 현재 클래스 내, 같은 패키지 내, 상속 받은 외부 패키지의 클래스에서 사용할 수 있는 매개변수 또는 함수 

      Public : 모든 곳에서 사용 가능

   5. 객체지향이란 무엇인가?

      기존의 단순한 데이터, 처리방법으로 나누는 것이 아닌. 세상을 모두 객체적인 관점에서 바라보고, 이것들관의 상호작용으로써 접근하는 것

   6. 다중 상속에 대해 설명하시오

      어떤 클래스가 하나 이상의 상위클래스로부터 여러가지 행동이나 특징을 상속받을 수 있는 것을 말한다.

   7. Interface는 무엇인고 왜 사용하는지 설명하시오

      Interface란 객체에 접근할때 의 경계면이자 기본 설계도이다. 동일한 목적 하에 동일한 기능을 수행하게끔 강제하는 것. 이것을 사용하는 이유는 다형성을 극대화하기 위함으로 개발코드 수정을 줄이고, 프로그램 유지보수성을 높이기 위해 이를 사용한다. 예를 들어 자동차라는 인터페이스를 통해 설계도면을 가지고 서로다른 여러 자동차를 만들어낼 수 있는 것입니다.

   8. Interface와 Abstract의 차이

      Interface 는 상수만 사용할 수 있기 때문에 추상클래스보다 변수사용에 있어서 훨씬 제한적이다.
      또 private, protected등 다양한 접근제한자를 사용할 수 없다. 
      마지막으로 Interface는 생성자가 없어서 생성시에 초기화해주는 작업이 필요한 경우 적합하지 않다.

      -----------------------------------------------------

      **공통점** : 선언만 있고, 구현 내용이 없는 클래스이다. 그래서 자기 자신이 new를 해서 객체를 생성할 수 없으며, 추상클래스를 extends받거나 interface를 implements한 자식만이 객체를 생성할 수 있다. 상속받은 자식이 구현을 반드시 하도록 해야할 때 사용한다. Java에서는 type이 지정되있기 때문에 선언된 type과 자식의 type이 같아야만 한다.

      **차이점** : 추상클래스는 말 그대로 클래스이고, interface는 구현하기 전에 메소드에 대해 명세된 것이다. 그래서 상속을 받음에도 불구하고 클래스에선 상속이라고 쓰지만 interface는 implements(구현) 이라고 쓴다. 추상클래스의 정의는 abstract 메소드가 하나라도 존재하는 클래스를 일컫는다. 때문에 일부는 구현된 메소드도 있고, abstract라고 붙어있는 메소드는 구현이 안되어있다. 추상클래스를 상속받는 클래스는 반드시 추상메소드를 구현해야한다. 그래서 필수적으로 구현해야할 메소드가 있을 때 추상클래스를 쓰게된다. 인터페이스는 구현체 없이, 메소드에 대한 명세만 되어있다. 인터페이스를 상속받는 클래스에서는 반드시 인터페이스에 있는 메소드를 다 구현해야한다. 자바는 단일상속을 지원하기 때문에 추상클래스는 단일상속이지만, interface를 사용하게 되면, implements를 구현하는 부분에서 extends 또한 사용할 수 있다. 즉 다중상속이 가능해진다.

      1. ~메소드를 쓸것이다(인터페이스) = 반드시 선언된 그대로 모두 구현해야한다.
      2. ~메소드가 있지만 가져다 쓰고나 오버라이드 하거나, abstract가 붙은 메소드는 반드시 구현하면 되는게 abstract class이다.

      #### 인터페이스에는 다형성(Polymorphism) 개념 등장!

      interface : 동물. Method : 먹는다, 걷는다, 잔다. = 구현체(implement) : 고양이, 원숭이, 병아리 동물 각각이 먹고 걷는, 자는 방식을 구현

      #### 추상클래스는 언제 쓰는가?

      야생고양이가 새끼를 낳았다. 인간에 의해 집고양이가 된 경우! 어미고양이(부모글래스)-야생고양이 -자는법 (메서드) -집에서 사는법(추상화 메서드) 새끼고양이(자식클래스)-집고양이 -자는법(메서드) -집에서 사는법(메서드) 어미고양이는 야생고양이므로 집에서 사는법은 모르지만, 새끼고양이는 집에서 사는법을 알려주기 위해 추상메서드로 만들었다. (구현 X)

      =인터페이스는 다형성! 추상화 상속은 부모-자식관계!

   9. final에 대해 설명하시오(3가지 용도, 왜 사용하는가)

      1. C에서의 const와 같은 역할로 상수를 만드는 역할을 한다.
      2. 클래스 앞에 final이 붙으면 클래스가 상속이 불가능하게 만든다.
      3. 메소드 앞에  final 이 붙으면 오버라이딩 되지 않게 만든다.

   10. final 클래스와 변수 선언의 차이를 설명하시오

       클래스 - 상속 자체가 안된다. 예를 들면 값들이 변경되면 안되거나 상수값들을 갖는 클래스가 사용

       변수 : 변경할 수 없는 상수값으로 됨.

   11. final, finally, finalize의 차이를 설명하시오

       final : 변경 못하도록 고정하거나, 클래스의 경우 상속을 못하도록, 메서드의 경우 오버라이딩을 못하도록 하는것.

       finally : 예외 처리에서 반드시 실행해야 하는 부분을 기술하는 것

       finalize : GC에 대상에서 정리가 되어야 할 대상. 회수해야할 것들. 이를 제대로 처리해야  OOME가 발생하지 않음.

   12. Java에서 Minor Garbage Collection과 Major Garbage Collection의 동작방식을 설명하시오

       Minor GC 에서는 Eden 영역에서 Survive1 or Survive2로 넘어간다. 두개의 Survive 영역중 하나가 가득 차면 아직 Root Set으로 부터 참조되고 있는 객체를 반대편 Survive 영역으로 옮긴다. 양쪽 Survive영역이 모두 차게 되었을 경우 Minor GC 가 일어나면서 Root Set으로 부터 참조되고 있는 객체들중 오래 살아남은 객체들은 Old 영역으로 옮긴다.
       Major GC 에서는 Old영역이 모두 차게 되었을 경우  g1GC, CMS GC, parerell GC, serial GC 등등 여러 알고리즘이 붙으며 작동한다. 

       Heap 사이즈가 클 수록 STW가 길게 발생하므로 무조건 Heap이 좋다고 능사가 아니다. 

       CMS 콜렉터 방식은 2개 이상의 프로세서를 사용하는 서버에 적당합니다. 가장 적당한 대상으로는 웹서버가 있습니다.

   13. Collection Framework에서 List, Set, Map 등의 특징을 모두 설명하시오

       List 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.

       Set 순서가 없고 데이터의 중복을 허가하지 않는다.

       Map 순서가 없고 데이터의 중복 중 Value만 허가 한다. 

   14. Exception 발생은 컴파일 과정에서 발생하는지 실행과정에서 발생하는지 설명하시오

       CheckException : IOException, SQLException 컴파일과정에서 발생
       UncheckedException :  NullPointerException, OOME 실행과정에서 발생

   15. JVM 구조에 대해 설명하시오

       Class Roader, Execution Engine, Runtime Data Area

   16. Java JVM에서 5가지 메모리 구조에 대해 설명하시오

       각각의 Thead 안에 PC register, JVM Stack, Native Method Stack, 

       그리고 Heap, Static(Method) Area-Runtime Constant Pool 

   17. JVM의 Heap 영역 중 Young 영역에서 Survivor부분이 Survivor1과 Survivor2로 나눠져있는 이유?

   18. JNI의 메모리 상에서 변환되어서 실행되는 과정

       JVM이 해당 바이너리 코드를 메모리에 올려서, 독립된 C 실행 프로그램으로써 실행하게 하고, 그 사이에 인자값이나 반환값에 대한 데이터 교환   (의 역할만을 보장하는 것)

   19. HashMap, HashTable, ConcurrentHashMap의 차이를 설명하시오

       HashMap : 동기화 지원 X, Null 허용

       ConcurrentHashMap : 동기화 지원 O, Null 허용 X

       HashTable : 동기화 지원 O, Null 허용 X 

       => HashTable는 Synchronized 키워드를 이용해서 메소드 전체에 락을 건다 따라서 확장성이 메우 떨어지며 이 객체를 참조하는 쓰레드 개수가 많아질수록 대기시간이 길어져 성능이 급격히 떨어진다,반면에 ConcurrentHashMap 은 내부적으로 여러 개의 세그먼트를 두고 각 세그먼트마다 별도의 락을 가지고 있다, 때문에 여러 쓰레드에서 이 객체에 동시에 데이터를 삽입, 참조하더라도 그 데이터가 다른 세그먼트에 위치하면 서로 락을 얻기 위해 경쟁하지 않는다. 이를 Lock Striping 이라 부른다.

   20. StringBuilder와 StringBuffer의 차이에 대해 설명하시오

       StringBuilder 는 동기화 지원을 하지 않기 때문에 단일 쓰레드 환경에서 사용하여야 한다. 대신 속도가 가장 빠르다.

       StringBuffer는 동기화를 지원하기 때문에 멀티 쓰레드 환경에서 사용하기 좋다. 둘다 가변하다는 점이 공통점이다. 그리고 문자열연산이 잦은 환경에서 쓰면 좋다.

   21. Try-with-resource에 대해 설명하시오

   22. Synchronize에 대해 설명하시오

   23. Synchronize를 하기 위한 방법은 무엇이 있는지 설명하시오

   24. Static은 메모리 구조 중 어디에 올라가는지 설명하시오

   25. 컬렉션 프레임워크에 대해 설명하시오

   26. 제네릭에 대해 설명하시오

   27. Vector와 List차이에 대해 설명하시오

   28. OOP에 대해 설명하시오

   29. new String()과 ""의 차이에 대해 설명하시오

   30. 스프링 IoC가 무엇인지 설명하시오

   31. OOP와 AOP의 차이에 대해 설명하시오

   32. Annotation에 대해 설명하시오

   33. Primitive, Object 할당시 어떤식으로 저장되는지 설명하시오.

   34.  C#과 Java의 차이점을 설명하시오

   35. Java8에 새롭게 추가된 3가지를 설명하시오

   36. Call By Value 와 Call By Reference의 차이점을 설명하시오

   37. Springboot autoConfiguration에 대해 설명하시오

   38. DTO, VO의 차이점에 대해 설명하시오

2. 웹

   1. Spring의 AOP에 대해 설명

      구현 방법 

      1. 컴파일 A.java--(AOP)-->A.class(AspectJ)

      2. 바이트코드 조작 A.java->A.class--(AOP)-->메모리(AspectJ)

      3. 프록시 패턴 (스프링 AOP) : 프록시 = 대행자

         스프링이 개발자가 핵심 비즈니스 로직에만 집중할 수 있도록, 필요하지만 중복해서 작성해야 하는 핵심 이외의 코드들은 외부로 빼놓는 것을 말한다.
         이것의 가장 큰 장점은 핵심 부분은 건드리지 않으면서 중복 코드를 제거할 수 있다는 것.

         1. 클래스에 @Aspect 주입

         2. 내부 코드블럭에 JoinPoint 설정(@Before, @After, @Around)

            ```java
            @Aspect
            @Component
            public class MeasureExecutionTimeAspect {
            	
            	// repository에 있는 모든 클래스의 메서드
            	@Around("execution(* *..repository.*.*(..))")
            	public Object aroundAdvice( ProceedingJoinPoint pjp) throws Throwable {
            		// before advice
            		StopWatch sw = new StopWatch();
            		sw.start();
            		
            		Object result = pjp.proceed();
            		
            		// after advice
            		sw.stop();
            		Long total = sw.getTotalTimeMillis();
            		
            		// 어떤 클래스의 메서드인지 출력하는 정보는 pjp 객체에 있다.
            		String className = pjp.getTarget().getClass().getName();
            		String methodName = pjp.getSignature().getName();
            		String taskName = className + "." + methodName;
            		
            		
            		// 실행시간은 로그로 남기는 것이 좋지만, 여기서는 콘솔창에 찍도록 한다.
            		System.out.println("[ExecutionTime] " + taskName + " , " + total + "(ms)");
            		
            		return result;
            	}
            }
            ```

   2. Spring의 DI에 대해 설명스프링에서는 다음과 같은 순서로 객체가 만들어지고 실행된다.

      

      1.객체 생성

      2.의존성 객체 주입(스스로가 만드는것이 아니라 제어권을 스프링에게 위임하여 스프링이 만들어놓은 객체를 주입한다.)

      3.의존성 객체 메소드 호출

      

      스프링이 모든 의존성 객체를 스프링이 실행될때 다 만들어주고 필요한곳에 주입시켜줌으로써 Bean들은 싱글턴 패턴의 특징을 가지며, 

      제어의 흐름을 사용자가 컨트롤 하는 것이 아니라 스프링에게 맡겨 작업을 처리하게 된다. 

      

   3. Spring의 장단점

      장점:EJB에 비해 가벼워 엔터프라이즈급의 시스템에 적합. 전체 구조를 설계할 때 유용한 프레임워크. 다른 프레임워크 포용.

      단점: 선택적으로 도입할 수 없는 복잡한 기술, 너무 다양한 방법을 제시, 높은 러닝커브

   4. Spring Boot 와 Spring의 차이점

      Spring Boot는 Spring 프레임워크에서 사여ㅛㅇ하는 프로젝트를 아주 간편하게 셋업할 수 있는 서브 프로젝트이다. 독립 컨테이너와 내장 톰캣이 있어 별도의 서버 설치 없이 실행되며, Dependency도 편리하게 추가할 수 있다.

   5. 브라우저의 주소창에 www.naver.com을 치면 발생하는 일 최대한 자세히 설명

      https://www.netmanias.com/ko/post/blog/5353/dns/dns-basic-operation

   6. 웹 사이트의 속도를 개선하는 방법

      -CDN을 사용해라 EX) Google Global Cache, 정적 리소스와 동적 리소스의 처리를 분리하여 진행한다.

   7. HTTP Method의 종류 설명

   8. MVC, MVVC, MVVM의 차이 설명

   9. MSA란 무엇인가?

   10. Open API 결과가 수십만개 일때 어떻게 하면 속도를 개선할지

   11. 트래픽이 많아질때 대처법

   12. 어떤 기능을 구현하는데 서버에 용량이 부족하다. 어떻게 구현할 것인가?

   13. 로그를 왜 찍어야 하는지

   14. 로그를 어디다 저장하는게 좋은지

   15. HTML과 HTML5의 차이

   16. 로드벨런싱이란

   17. 로드벨런싱과 클러스터링 개념과 차이

   18. 프록시 서버에 대한 설명

   19. 포워드, 리버스 프록시 서버를 왜 쓰는지 및 장단점

   20. REST, Restful API, REST 원칙 설명

   21. Redis에 대해 설명

   22. 서버 구축시 사용하는 Web Server, WAS 차이점

   23. 고가용성(HA)에 대해 설명

   24. 클라우드의 종류에 대해 설명

3. 컴퓨터 네트워크

   1. HTTP, TCP, UDP에 대해 설명
   2. TCP, UDP의 차이
   3. TCP의 nagle 알고리즘 과정에 대해 직접 그리면서 설명해보시오
   4. 3-way hanshake 과정에서 통신이 안되면 어떤일이 벌어질지 설명
   5. 4-way hanshake 종료과정 설명
   6. HTTP 통신을 API 안쓰고 하려면?
   7. TCP, UDP에서 Checksum의 특징 및 차이에 대해 설명
   8. TCP/IP에 대해 설명
   9. TCP Flag 종류 설명
   10. OSI 7계층을 왜 나눴는지 설명
   11. HTTP와 HTTPS의 차이
   12. 프로토콜에 대해 설명
   13. 도메인, DNS에 대해 설명
   14. 빅, 리틀 인디안에 대해 설명
   15. 리피터, 스위치에 대해 설명
   16. SSL에 대해 설명
   17. ARP, RARP에 대해 설명
   18. ICMP에 대해 설명

4. 데이터베이스

   1. JOIN의 종류 설명
   2. Inner Join, Outer Join 차이를 벤다이어그램으로 설명
   3. DB Index 설명 및 왜 쓰는지
   4. DB Index의 트리 구조 설명
   5. 클러스터링 인덱스란?
   6. 클러스터링과 non-클러스터링의 차이
   7. collision 해결방법
   8. DB Isolation 설명
   9. 상황을 이해해서 ERD 설계 및 그리기
   10. 그린 ERD에 따라 처리프로세스 설명
   11. NoSQL과 RDBMS의 차이
   12. 정규화 개념과 각 단계별 설명

5. 프로그래밍 언어

   1. 다형성이란?
   2. 오버로딩과 오버라이딩의 차이
   3. 오버로딩과 오버라이딩개념에서 리턴값은 같아야 되나?
   4. C와 Java의 차이(+Java가 더 나은 점)
   5. Java와  JavaScript 중 어떤 언어가 더 좋은지?
   6. 객체끼리 비교할 때 어떻게 같은 객체인지 아는지? (equal)
   7. 업캐스팅, 다운캐스팅에 대해 설명하시오
   8. Garbage Collection이 무엇인지 설명하시오

6. 소프트웨어 공학

   1. 아는 디자인패턴 10가지 설명
   2. 싱글톤이 무엇이고 왜 쓰는지?(JDK 8부터 클래스 생성시 기본값 싱글톤)
   3. 싱글톤을 쓰면 멀티스레드 환경에서 스레드세이프 한지?
   4. 멀티스레드 환경과 단일스레드 환경에서 싱글톤 차이
   5. 싱글톤 외에 스레드세이프하게 구현할 수 있는 디자인 패턴은?
   6. 싱글톤에서 스레드세이프하도록 손코딩
   7. 팩토리 패턴의 장점
   8. 옵저버 패턴이 뭔지와 왜 쓰는지?
   9. 객체지향적으로 도형에 관한 클래스 손코딩
   10. API 란 무엇인가?
   11. 라이브러리랑 프레임워크의 차이
   12. 객체지향의 3요소 5원칙(SOLID)

7. 자료구조

   1. 스택으로 큐를 구현하기
   2. 각 정렬의 시간 복잡도 비교
   3. 퀵소트의 시간복잡도, 왜 그 시간복잡도인가? 개선방법?
   4. 이진트리의 탐색횟수

8. 알고리즘

   1. A* 알고리즘(휴리스틱 기반 길찾기 알고리즘)
   2. Big-O 설명
   3. IDX를 알때, ArrayList, LinkedList, BinarayTree, HashMap의 시간복잡도
   4. DFS/BFS 설명
   5. 문서를 압축하는 다양한 알고리즘에 대해 설명
   6. 컨테이너를 정렬하는 알고리즘 손코딩
   7. 아호코라식 알고리즘
   8. Generic Queue 손코딩

9. 운영체제

   1. 프로세스와 스레드의 차이

   2. 메모리 구조에서 스택과 큐의 역할

   3. 뮤텍스와 세마포어의 차이

   4. 사용해본 운영체제는?

   5. 리눅스에서 아는 명령어?

   6. 리눅스에서 Top 키워드는?

   7. 페이지 교체 알고리즘 종류와 방식 설명

   8. Context switching의 오버헤드의 주원인

   9. 유닉스 fork. 함수

   10. 데드락에 대해 설명, 해결 방법

       -한정된 자원을 여러 곳에서 사용하려고 할 때 발생하는 교착 상태. 

       -멀티 프로그래밍 환경에서 대기 상태로 들어간 프로세서들이 실행 상태로 변경될 수 없는 상황.

       4가지 발생 조건

       1. 상호 배제 - 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.
       2. 점유 대기 - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.
       3. 비선점 - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.
       4. 순환 대기 - 프로세스의 집합에서 P0는 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고 ~~ Pn은 P0가 점유한 자원을 요구해야 한다.

       3가지 해결 방법

       1. 교착 상태 예방 및 회피 - 교착상태가 되지 않도록 보장하기 위하여 교착상태를 예방하거나 회피하는 프로토콜을 이용하는 방법 (자원 낭비가 심하다) 

          -상호 배제 부정 = 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다.

          -점유 대기 부정 = 프로세스가 실행되기 전 필요한 모든 자원을 할당한다.

          -비선점 부정 = 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 한다.

          -순환 대기 부정 = 자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다.

       2. 교착 상태 탐지 및 회복 - 교착 상태가 되도록 허용한 다음에 회복시키는 방법

       3. 교착 상태 무시 - 대부분의 시스템은 교착 상태가 잘 발생하지 않으며, 교착 상태 예방, 회피, 탐지, 복구하는 것은 비용이 많이 든다.

   11. 메모리 단편화와 해결책

   12. 코드를 주고 lock을 꼭 걸어야 하는 위치 찾기

10. 컴퓨터구조

    1. Call by value, Call by reference, Call by address
    2. 버퍼 오버 플로우

11. 보안

    1. 공개키 비밀키
    2. 대칭키

12. 인성



IP는 Subnet-Mask로 Network/Host로 분리
Network가 동일 하면 Local Area Network = > L2 Switch가 Mac을 보고 목적지 결정
Network가 다르면 Wide Area Network => L3 Router가 IP를 보고 목적지 결정

ARP : Local Area Network에 있는 특정 IP를 가진 Host의 Mac을 얻어온다.
ICMP : IP를 가진 Host와 통신이 되는지 확인

