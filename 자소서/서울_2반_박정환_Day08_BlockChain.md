1. 기본과제 스크린샷

   ![image](https://lab.ssafy.com/hwxnii/self-online/raw/master/day8/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202020-03-18%20%EC%98%A4%EC%A0%84%2010.36.33.png)

2. 활용사례

   ### Direct-address-table

   해시 테이블이 생성되기 이전에 쓰이던 방식이다.

   키 값을 그대로 index로 사용하고, 포인터로 데이터를 연결한다. **실제 사용하지 않는 키가 있음에도 불구하고 그 만큼의 저장공간을 차지한다.** 이로인해 메모리의 효율성이 떨어진다.

   

   ![img](https://k.kakaocdn.net/dn/bAfu94/btqvdkuyCvM/6goNEp1kyy7uT3wWnGyhO0/img.png)Direct-address-table모형

   

    

   해시 테이블의 크기(m)가 실제 사용하는 키의 개수(n)보다 적은 해시 테이블을 사용한다. 이 때, n/m을 load factor라고 한다. 해시 테이블의 한 버킷에 평균 몇 개의 키가 매핑되는가를 나타내는 지표이다. **찾고자 하는 데이터의 key값만 안다면 바로 데이터에 대한 탐색/저장/삭제/갱신은 계산 복잡성이 O(1)이다.** 매우 빠른 속도로 처리가 가능하다. **다만, 모든 key값이 활용되지도 않음에도 불구하고 모두 메모리 공간을 차지하고 있어야 되기에 메모리 낭비가 발생**한다.

   ### 해시 테이블

   효율적인 탐색을 위한 자료구조로서 키(key)를 값(value)에 대응시킨다. 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 검색 속도가 빠르다. 검색 속도가 빠른 이유는 **key값을 해시함수에 넣고 리턴되는 해시코드로 배열의 인덱스를 찾고 바로 직접 접근하여 그 배열에 있는 데이터를 읽거나 저장**한다. 데이터를 저장할 땐 연결리스트로 한다. **해시코드는 고유한 값을 리턴하기 때문에** 삽입 연산 시 다른 데이터의 사이에 끼어들거나, 삭제 시 다른 데이터로 채울 필요가 없기 때문에 연산에서 **추가적인 비용이 없고 속도도 빠르다.**

   특징: 해시 테이블은 데이터가 입력되지 않은 여유공간이 많아야 제 성능을 유지할 수 있다. 공간 사용률이 70~80%부터 성능 저하가 일어난다.

   

   ![img](https://k.kakaocdn.net/dn/c4idzv/btqu9AeAjbn/pz5FFWeksstfWkAMXCCob0/img.png)

   

   ### 해시 함수란?

   **어떤 길이의 데이터를 입력해도 고정된 길이의 결과(해시 값)를 출력하는 함수다.**

   그렇기 때문에 책 줄거리를 넣든, Hello라는 단어를 넣어도 똑같은 길이의 해시값을 리턴한다. 그렇기 때문에 **결과 값만 가지고 입력값을 찾기가 무척 힘들다**. 이에 널리 사용되고 심지어 보안에서도 자주 사용된다. 그리고 **입력 값의 아주 일부만 변경되어도 전혀 다른 결과 값을 출력**한다.(눈사태 효과) 그리고 **같은 입력값에는 항상 같은 해시값을 출력**한다. 또한 결과값이 중복될 가능성이 거의 없지만 중복이 되는 경우도 있는데 이를 **해시충돌**이라고 하며, 충돌이 일어날 확률이 가장 적은게 가장 좋은 해시함수이다.

    

   해시함수는 저장될 값의 key값을 해시함수를 통해서 작은 범위의 값들로 바꿔준다. 수식으로 바꿔 보자면 아래와 같다.

   h(k) = k % m (항상 0~m-1 사이의 정수가 됨)

    

   해시함수의 종류로는 MD5, SHA-1, SHA-256등이 있으며 MD5는 이미 해시충돌이 발견되어 SHA-1이상의 해시함수를 권장합니다.

    

   ### 해시 충돌이라는 치명적인 단점에도 사용하는 이유는?

   **1. 적은 리소스로 많은 데이터를 효율적으로 관리가 가능하다.**

    

   **2. 예를 들어 하드디스크나 클라우드에 존재하는 무한의 데이터들은 유한한 개수의 해시 값으로 매핑하여 작은 크기의 캐시메모리로도 프로세스 관리가 가능하다.**

    

   **3. 색인(index)에 해시값을 사용하여 모든 데이터를 살피지 않고 삽입/삭제가 빠르게 수행될 수 있다.**

    

   **4. 해시 함수는 언제나 동일한 해시 값을 리턴하고, 해당 색인만 알면 해시 테이블의 크기에 상관없이 데이터에 대단히 빠르게 접근이 가능하다. 색인(index)는 계산이 가능한 간단한 함수로 작동하기에 효율적이다. 데이터 액세스시 계산 복잡성이 O(1)을 지향한다.**

    

   **5. 키(key)와 해시 값(hash value) 사이에 직접적인 관계가 없으므로 보안에서도 많이 활용됨**

   ### 해시 함수 만들기

   대표적인 두 가지 방법이 있는데 나누기방법과 곱하기 방법이다.

    

   **1. 나누기 방법**

   나누기 방법은 **원소를 해시 테이블의 크기로 나누어 나머지의 값을 테이블의 주소로 사용**하여 저장하는 방법이다.

   

   ![img](https://k.kakaocdn.net/dn/9ccUa/btqvdlGXY6q/VGQdsfNavVHPXRkEkwokWk/img.png)

   

   위의 예제는 해시 테이블의 크기가 13일 때 해시함수에 25, 13, 16, 5, 7의 입력값이 주어진 경우다. 25는 25mod13 = 12이므로 12번째 인덱스에 저장되었고 13은 13mod13=0이므로 0번째 인덱스에 저장되었다. 나누기 방법의 해시함수의 식은 다음과 같다.

   #### h(x) = x mod m

   **해시 테이블의 크기 m은 2의 멱수에 가깝지 않은 소수를 택하는 것이 좋다**. 해시값은 입력 원소의 모든 비트를 이용하는 것이 확률적으로 좋은 분포를 갖도록 하는데 유리하다.

    

   **2. 곱하기 방법**

   나누기 방법은 해쉬 테이블 크기보다 큰 수를 해시 테이블 크기 범위에 들어오도록 수축시킨다. 곱하기 방법은 **이와 반대로 먼저 입력값을 0과 1사이의 소수로 대응 시킨 다음 해시 테이블 크기 m을 곱하여 0~m~1 사이로 팽창시킨다.** 이방법에서는 해시함수의 특성을 결정짓는 0<A<1의 범위의 상수 A를 미리 준비해야한다. 임의의 원소 x에 대해 다음과 같은 과정을 거쳐 x의 주소를 결정한다. 

    

   x에 A를 곱한 다음 소수부만 취한다. 그리고 취한 소수부에 m을 곱하여 그 정수부를 취한다.

    

   

   ![img](https://k.kakaocdn.net/dn/bppJD6/btqu9zs8IxU/66sJpXqKoIFYwJvAmKphxk/img.png)

   

   ### 해시충돌 처리하기 - 체이닝, 개방 주소

   충돌해결에는 크게 두 가지 방법이 있다. 

   ### **체이닝**

   해시 테이블의 각 주소가 연결 리스트의 헤더 역할을 하고, 여기에 해당 주소로 들어오는 원소들이 연결 리스트로 매달린다. 즉, **같은 해시값을 공유하는 데이터를 연결리스트로 연결해서 값을 찾는다.** 

   삽입은 효율성을 위해 연결리스트의 맨 앞에 삽입한다. 맨 뒤에 삽입할 경우 삽입마다 연결리스트를 따라 맨 끝으로 이동해야 하므로 낭비가 된다.

   

   ![img](https://k.kakaocdn.net/dn/bdMTsd/btqvdlfV0b9/zOKZo9aUdXRwOGeRIhkYM0/img.png)

   

   **장점으로는** 복잡한 계산식이 필요가 없고 개방주소 방법보다 간소하다. 하지만 해시 테이블이 채워질 수록 성능저하가 일어난다. (연결리스트는 데이터가 많을 수록 탐색속도에 불리)

   ### **개방 주소**

   체이닝 처럼 추가 공간을 사용하지 않고 해시 테이블 안에서 충돌을 해결한다. 원래 들어갈 자리가 아니더라도 테이블의 다른 자리를 찾아 들어가게 된다. 즉, 해시 함수를 계산하여 계산된 주소를 차지 하고 있다면 정해진 규칙에 따라 다음 자리를 찾는다. 예를 들어 0번째 자리에서 충돌이 나면 다음 주소인 1번째에 넣는다. 와 같은 규칙으로..

    

   이러한 다음 주소를 결정하는 방법은 대표적으로 3가지가 있다.

   **장점으로는** 체이닝처럼 포인터가 필요없고, 지정한 메모리 외 추가적인 저장공간도 필요없다. 삽입, 삭제시 오버헤드가 적고 저장할 데이터가 적을 때 더 유리하다.

   ### **개방 주소 - 선형조사**

   선형 조사는 가장 간단한 충돌 해결 방법으로, 충돌이 일어난 바로 뒷자리를 보는 것이다. 이렇게 하면 i번째 해시함수는 h(x)로 부터 i만큼 떨어진 자리가 된다. 테이블의 경계를 넘어갈 경우에는 맨 앞으로 돌아간다.

   

   ![img](https://k.kakaocdn.net/dn/bhOyKD/btqvdkH4stH/NFhZkkw6u9sKkxxzPvRkTk/img.png)

   

   선형 조사의 경우 특정 영역에 원소가 몰릴 때는 치명적으로 성능이 떨어진다. 이런 형상을 1차군집이라 한다. 이렇게 되면 평균 검색시간과 삽입시간이 증가하게 된다.

   ### **개방 주소 - 이차원 조사**

   이차원 조사는 바로 뒷자리를 보는 선형 조사와 달리 보폭을 이차함수에 의해 넓혀가면서 본다. 예를 들면 i번째 해시함수를 h(x)로 부터 i^2만큼 떨어진 자리로 삼을 수 있다. 즉, h(x), h(x)+1, h(x)+4, h(x)+9...과 같이 볼 수 있다.

   해시값+해시값제곱을 다시 mod해서 자리를 재배치 한다.

    

   이렇게 하면 선형 조사에서 처럼 특정 영역에 원소가 몰려도 그 영역을 빨리 벗어날 수 있다. 그러나 여러 개의 원소가 동일한 초기 해시함수 값을 갖게 되면 모두 같은 순서로 조사를 할 수 밖에 없어 비효율적이게 된다. 이런 현상을 2차 군집이라 한다.

   

   ![img](https://k.kakaocdn.net/dn/cqK23W/btqvb5YXW5k/lwclKRKKSx3rXfUcHFvIrk/img.png)

   ![img](https://k.kakaocdn.net/dn/bmtR3r/btqvceVEIau/umEik1fyVe3Py0BqjE8bok/img.png)

   

   ### 개방 주소 - 더블 해싱

   더블 해싱은 두 개의 함수를 사용한다. 더블 해싱에서 i번째 해쉬 함수는 다음과 같다.

   

   ![img](https://k.kakaocdn.net/dn/b1r6Du/btqvcfG1r2f/klKcq6nkMBsVil9CRYVKH0/img.png)

   

   여기서 h(x)와 f(x)는 서로 다른 해시함수다. 충돌이 생겨 다음에 볼 주소를 계산할 때 두 번째 해시 함수값 만큼씩 점프한다. 더블해싱에서 조심할 점은 두 번째 해시 함수 값 f(x)가 해시 테이블 크기 m과 서로 소인 값이어야 한다는 것이다. 만일 f(x)와 m이 1보다 큰 최소공약수 d를 가지면 x의 자리를 찾기 위해 해시 테이블 전체 중 기껏해야 1/d 밖에 보지 못하게 된다.

    

   두 개의 해시함수를 정하는데 있어서 권장하는 방법은 h(x)=x mod m으로 잡고, m보다 조금 작은 소수 m`에 대해 f(x)=1+(x mod m`)으로 잡는 것이다. 여기서 핵심인 i의 값은 충돌된 횟수 만큼을 뜻한다.

   

   ![img](https://k.kakaocdn.net/dn/bJzVXm/btqvbOQFUIQ/pgWW6pQMVFWcqH26rZkxlk/img.png)

   

   ## 결론

   해시 테이블은 **데이터를** **정렬된 순서로 접근하는 것에 엄청난 비용이 발생**한다. 또한 해시 테이블은 구현 및 사용이 좀 더 어렵고 문제를 수반하기 쉽상이다. 모든 key type에 대해 강력한 해시 함수를 요구하는데, **다른 자료구조의 간단한 비교 함수에 비해 설계하기도 구현하기도 디버그하기도 만만치 않다.** 특히 open-addressing 방식에서는 **질 낮은 해시 함수를 만들기가 쉽다.**

    

   하지만 최근 Java등에서 map이 HashMap으로 대체되는 등, 검색이 주요 동작인 자료구조의 핵심이 되고 있다. **트리의 높이에 탐색 시간이 비례하는 map에 비해 평균적으로 O(1)의 탐색 시간을 보장하는 hashmap이 훨씬 좋음**은 두 번 말해 입이 아플 정도다. **Hash는 구현하기가 어려운 자료구조가 아니나, 아름답게 구현하기가 무척 어렵다**. **뛰어난 해시함수를 구현하거나 찾고, 원만한 충돌 해결 알고리즘을 사용할 수 있다면 hash는 반드시 강력한 도구가 될 것.**