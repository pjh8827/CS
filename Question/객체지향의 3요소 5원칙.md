# 객체지향의 3요소 5원칙

## 3요소

캡슐화(Encapsulation), 다형성(Polymophism), 상속(Inheritance)

## Encapsulation 캡슐화

-프로그램 내에서 같은 기능을 목적으로 작성된 코드를 모아서 다른 곳(클래스)에서 안보이게 숨기는 것. 클래스에 정의된 속성(Attribute)은 숨기고(Private), 객체가 수행할 기능(Function)은 공개(Public)하는 것을 의미한다.

## Inheritance 상속

-클래스 사이에 부모와 자식 클래스가 존재할 수 있다는 뜻. 자식 클래스는 상속받은 부모 클래스의 속성(변수) 및 기능(메소드, 함수)를 물려받는 것을 의미한다.

- 부모 클래스와 자식 클래스는 자바 지정예약어 extends에 의하여 정해진다.
- 하나의 부모 클래스는 자바 지정 예약어 extends에 의하여 정해진다.
- 반대로 하나의 클래스는 여러개의 클래스로부터 상속을 받을수는 없다. 
- 부모 클래스로부터 상속받은 자식 클래스는 부모 클래스의 자원 모두를 사용할 수 있다.
- 반대로 부모클래스는 자식클래스의 자원을 가져다 쓸 수 없다.
- 자식클래스는 또다른 클래스의 부모 클래스가 될 수 있다.
- 자식클래스는 부모클래스로부터 물려받은 자원을 Override 하여 수정해서 사용할 수 있다. 
- 부모클래스가 상속받은 자원도 자식클래스가 사용 가능하다.

## Polymophism 다형성

-여러가지 형태를 가질 수 있는 능력, 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함.

1 다형성: 하나의 객체를 여러 개의 타입으로, 하나의 타입으로 여러 종류의 객체를 여러 가지 모습으로 해석될 수 있는 성격이라고 생각하면 된다.

vo.) 다형성(Ploymorphism): 'poly'는 다양한, 많은/‘morp'는 형태



2 다형성은 하나의 객체를 여러 가지 타입으로 선언할 수 있다는 뜻이다.

다형성은 개발자들에세는 간단히 말해서 하나의 사물(객체)을 다양한 타입으로 선언하고 사용할 수 있다는 의미로 해석해주면 된다. 일반적으로 어떤 객체가 하나의 분류에만 포함되는 것은 아니다. 대한민국의 국민인 동시에, 남자인 동시에, 서울에 사는 사람 등과 같이 이처럼 다형성은 어떤 사물을 여러 가지 시선으로 바라보는 모습을 생각하면 쉽게 이해할 수 있다.



3 Java에서 다형성은 상속과 인터페이스를 통해 이루어진다.

다형성의 의미는 하나의 객체를 다양한 시선(타입)으로 바라볼 수 있게 한다는 의미이다.

중요한 것은 다양한 타입으로 본다는 사실 자체가 아니라 다양한 타입으로 객체를 바라보게 되면 호출할 수 있는 메소드 역시 타입에 따라 달라진다는 것이다. 상속의 오버라이딩을 설명하면서 오버라이딩을 하게 되면 컴파일러는 실제 객체의 메소드를 바라보는 것이 아니라. 변수 선언 타입의 메소드를 본다.

Mouse m = new WheelMouse( );

실제 객체가 WheelMouse이지만 컴파일러는 Mouse 타입의 메소드가 정상적으로 호출되고 있는지에만 관심을 두게 된다.



4 인터페이스가 상속보다 다형성에 더욱 유연함을 제공한다.

인터페이스는 클래스의 선언 뒤에서 여러 개의 인터페이스를 구현할 수 있게 할 수 있다. 이런 이유 때문에 하나의 객체를 여러 개의 타입으로 바라보는 다형성에는 상속보다 인터페이스가 더 큰 유연함을 제공한다고 할 수 있다.

# SOLID 5원칙 

S: Single Responsibility Principle, 단일 책임 원칙
= 객체는 단 하나의 책임만 가져야 한다. (강한 응집력, 약한 결합력)
응집도 : 한 프로그램의 요소가 얼마나 뭉쳐있는지, 즉 구성 요소들 사이의 응집력
결합도 : 프로그램 구성 요소들 사이가 얼마나 의존적인지를 말한다.

O: Open-Closed Principle, 개방 폐쇄 원칙
= 기존의 코드를 변경하지 않으면서(Closed), 기능을 추가할 수 있도록(Open) 설계가 되어야 한다는 원칙. 즉 확장에 대해서는 개방적, 수정에 대해서는 폐쇄적인 것

L: Liskov Substitution Principle, 리스코프 치환 원칙
=자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙, 즉 자식 클래스는 언제나 부모 클래스의 역할을 대체할 수 있어야 한다는 것.
  자식 클래스가 부모의 기능에 대해 오버라이드 되지 않도록 하면 된다. 즉 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 하여야 한다.

I: Interface Segregation Principle, 인터페이스 분리 원칙
= 자신이 사용하지 않는 인터페이스는 구현하지 말하야 한다는 설계 원칙. 즉 하나의 거대한 인터페이스 보다는 여러 개의 구체적인 인터페이스가 낫다.

D: Dependency Inversion Principle, 의존 역전 원칙
= 객체들이 서로 정보를 주고 받을 때 의존 관계가 형성되는데, 이 때 객체들은 나름대로의 원칙을 갖고 정보를 주고 받아야 한다는 설계 원칙.
나름대로의 원칙 = 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다. 인터페이스를 통한 캡슐화를 활용하면 이 원칙을 준수할 수 있다. 
(아이가 장난감을 가지고 노는데, 구체적인 장난감은 변하기 쉽지만 아이가 가지고 노는 것이 장난감이란 사실은 변하기 어렵다. 아이->장난감(Interface)<-로봇, 모형 자동차, 레고)



























