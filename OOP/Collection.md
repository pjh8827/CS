# Collection

Java  Collection 에는 List, Map, Set 인터페이스를 기준으로 여러 구현체가 존재한다. 이에 더해 Stack과 Queue 인터페이스도 존재한다. 왜 이러한 Collection을 사용하는 것일까? 그 이유는 다수의 Data를 다루는데 표준화된 클래스들을 제공해주기 때문에 DataStructure를 직접 구현하지 않고 편하게 사용할 수 있기 때문이다. 또한 배열과 다르게 객체를 보관하기 위한 공간을 미리 정하지 않아도 되므로, 상황에 따라 객체의 수를 동적으로 정할 수 있다. 이는 프로그램의 공간적인 효율성 또한 높여준다.

![스크린샷 2019-11-06 오후 9.36.17](/Users/user/Desktop/스크린샷 2019-11-06 오후 9.36.17.png)

## List - 순서를 유지저장, 중복가능

List 인터페이스를 직접 @Override를 통해 사용자가 정의하여 사용할 수도 있으며, 대표적인 구현체로는 ArrayList가 존재한다. 이는 기존에 있었던 Vector를 개선한 것이다. 이외에도 LinkedList등의 구현체가 있다.
Vector: 동기화된 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소드들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드가 실행할 수 있다. 그래서 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다.
ArrayList: 데이터에 대한 인덱스를 가지고 있어 조회 기능 우수
LinkedList: 데이터에 대한 잦은 삽입, 삭제가 일어날때 우수

## Map - 순서 X, 값만 중복가능

대표적인 구현체로 HashMap이 존재한다. (밑에서 살펴볼 멀티스레드 환경에서의 개발부분에서 HashTable과의 차이점에 대해 살펴본다.) Key-value의 구조로 이루어져 있으며 Map에 대한 구체적인 내용은 DataStructure 부분의 HashTable과 일치한다. Key를 기준으로 중복된 값을 저장하지 않으며 순서를 보장하지 않는다. Key에 대해서 순서를 보장하기 위해서는 LinkedHashMap을 사용한다.
HashTable - 느리지만 동기화 지원, null 불가
HashMap - Null 가능(1개)
TreeMap - 정렬된 순서대로 키(key)와 값(value)을 저장하여 검색이 빠름

![스크린샷 2019-11-16 오후 9.50.50](/Users/user/Desktop/스크린샷 2019-11-16 오후 9.50.50.png)

## Set - 순서 X, 중복 X

대표적인 구현체로 HashSet이 존재한다. Value에 대해서 중복된 값을 저장하지 않는다. 사실 Set 자료구조는 Map의 Key-value 구조에서 Key대신에 Value가 들어가 Value를 Key로 하는 자료구조일 뿐이다. 마찬가지로 순서를 보장하지 않으며 순서를 보장해주기 위해서는 LinkedHashSet을 사용한다.

![스크린샷 2019-11-06 오후 9.54.54](/Users/user/Desktop/스크린샷 2019-11-06 오후 9.54.54.png) 
HashSet = 문자열을 여기에 저장할 경우, 깊은 문자열을 갖는 String 객체는 동등한 객체로 간주되고 다른 문자열을 갖는 String 객체는 다른 객체로 간주되는데, 그 이유는 String 클래스가 hashCode()와 equals()메소드를 재정의해서 같은 문자열일 경우 hashCode()의 리턴값을 같게, equals()의 리턴값은 true가 나오도록 오버라이딩이 되있기 때문이다. (**동일한 해시코드에 저장가능??**)
HashSet - 가장 빠른 임의의 접근 속도, 순서 예측 불가능
TreeSet - 정렬방법을 지정할 수 있음

## Stack과 Queue

Stack 객체는 직접 new키워드로 사용할 수 있으며, Queue 인터페이스는 JDK1.5부터 LinkedList에 new 키워드를 적용하여 사용할 수 있다. 자세한 부분은 DataStructure 부분의 설명 참고.